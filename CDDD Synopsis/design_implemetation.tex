\graphicspath{ {images/} }
\chapter{Design \& Implementation}
\hspace{5mm} In previous chapter when you finished literature to understand methods.Their may be many methods to develop your proposed system.But one which you chose to implement that need to be design in this chapter.
\par \textbf{Implementation} must contain algorithms or pseudo codes which used in your project

\section{Design}
\subsection{System Architecture}
\hspace{5mm}This part contain architecture(figure) which can be either flow design or analytic model or mathematical model or any other design.
\par database design also included in this part.
\begin{figure}[h!]
\begin{center}
\scalebox{0.50}{\includegraphics{SSO.jpeg}}
\end{center}
\caption {System Architecture}
\label{vmb2}
\vspace{0mm}
\end{figure}

\par here you can explain which methodology you followed for your project through designs.Their can one or more designs based on your project.

\section{Implementation}
\hspace{5mm}In this section all algorithms or any other implementation procedure need to explain with proper flow.
\par describe every procedure or algorithm with necessary diagram.
\par also explain different technology or languages you used for implementation/Deployment.  


The most important security advantage that a SSO implementation offers is a common secure infrastructure, which can be carefully managed and protected~\cite{andro}.
Single sign-on reduces human error, a major component of systems failure and is therefore highly desirable but difficult to implement.
\par For example, in an enterprise using SSO software, the user logs on with their id and password. This gains them access to low risk information and multiple applications such as the enterprise portal. However, when the user tries to access higher risk applications and information, like a payroll system, the single sign on software requires them to use a stronger form of authentication. This may include digital certificates, security tokens, smart cards, biometrics or combinations thereof. 
Single sign on can also take place between enterprises using federated authentication. For example, a business partner's employee may successfully log on to their enterprise system. When they click on a link to your enterprise's application, the business partner's single sign on system will provide a security assertion token to your enterprise using a protocol like SAML, Liberty Alliance, WS Federation or Shibboleth. Your enterprise's SSO software receives the token, checks it, and then allows the business partner's employee to access your enterprise application without having to sign on.

Single sign on federated authentication also works with your employees. For example, an employee who is trying to access your outsourced benefits supplier to update their benefits information would click on the benefits link on your intranet. Your enterprise's single sign on software would then send a security assertion token to the benefits supplier. The benefits supplier's SSO system would then take the token, check it and grant access to your employee without making them sign on.

\subsection{Single Sign On Benefits}
\hspace{5mm} Single sign on benefits are:
 \begin{itemize}
     \item Ability to enforce uniform enterprise authentication and/or authorization policies across the enterprise
    \item End to end user audit sessions to improve security reporting and auditing
    \item Removes application developers from having to understand and implement identity security in their applications
    \item Usually results in significant password help desk cost savings
\end{itemize}
Figure 3.1 depict single-sign on scenario.

\begin{figure}[h!]
\begin{center}
\scalebox{0.50}{\includegraphics{SSO.jpeg}}
\end{center}
\caption {Basic Single-Sign on Paradigm}
\label{vmb2}
\vspace{0mm}
\end{figure} 

\subsection{SAML 2.0}
\hspace{5mm} The Security Assertion Markup Language
(SAML) standard defines a framework for exchanging security information between online business partners. It was developed by the Security Services Technical Committee (SSTC) of the standards organization OASIS (the Organization for the Advancement of Structured Information Standards).SAML is different from other security systems due to its approach of expressing assertions about a subject that other applications within a network can trust. 
The four main purposes behind the
creation of the SAML standard are:
\begin{itemize}
\item Browser cookie limitations
\item SSO interoperability
\item Web services security
\item Identity federation
\end{itemize}

There are two very important concepts
that play an important role in the SAML
standard:
\begin{itemize}
\item Identity Provider (IdP) – is the
system or the domain that asserts
that a user has been authenticated
and has associated attributes. In
SAML, Identity Providers are also
known as SAML authorities and
Asserting Parties.
\item Service Provider (SP) – is the system
or administrative domain that relies
on information supplied by the
Identity Provider.
\end{itemize}
\par
The Service Provider decides if it trusts or not the information provided by the IdP. Service Providers are also known asRelying Parties – due to the fact that
they “rely” on information provided by
an Identity Provider (Asserting Party).
SAML consists of some block components that supports a number of use cases. First of all, these components permit transfer of identity, authentication, attribute
and authorization information between
autonomous systems that have a trust
relationship. The core SAML specification
defines the structure and content of both
assertions and protocol messages used
to transfer this information.
SAML assertions carry statements about
a principal that an asserting party claims
to be true. The valid structure and
contents of an assertion are defined by
the SAML assertion XML schema.
Assertions are usually created by an
asserting party based on a request of
some sort from a relying party, although under certain
circumstances, the assertions can be delivered to a relying party in an unsolicited manner. SAML
protocol messages are used to make the SAML-defined
requests and return appropriate responses. The structure and contents of these messages are
defined by the SAML-defined protocol XML schema.


\subsection{SAML implementation for SSO}
\hspace{5mm} Prerequisites for authentication is single sign on must be enable in our computer.This system requires uses the SAML 2.0 for Single Sign-On authentication. SAML 1.1 is not supported. 
\par The metadata document describes a service provider to an identity provider, including the following elements:
\begin{itemize}
    \item The endpoint addresses for communication
    \item The X.509 certificates being used to encrypt and sign SAML assertions
    \item The SAML bindings supported by the service provider
\end{itemize}

To configure SAML settings for single sign-on from identity provider to system
\begin{itemize}
\item Gather information from your identity provider.
\item Provide information to your identity provider.
\item from Setup, click Security Controls, Single Sign-On Settings, and edit neccerary changes regarding host ip.
Select
\item You must enable SAML to view the SAML single sign-on settings.
\item Specify the SAML version used by your identity provider.
\item In SAML Single Sign-On Settings, click New.
\item Give this setting a Name for reference within your organization.
\item provider inserts the corresponding API Name value, which i can customize if necessary.
\item If you are enabling just-in-time provisioning for security.
\item Enter the id,this is often referred to as the entity ID for the identity provider.
\item Organization's domains/server ip use for deployment, specifying whether to use the base domain or the custom domain for the Entity ID. we have to share this information with identity provider.
\item Generate key certificate for secure connection. 
\end{itemize}

\subsection{Policy Rules}
\hspace{5mm} For server side and client side XACML version 2.0 used to write policy rules.
\subsubsection{XACML}XACML(eXtensible Access Control Markup Language) is an OASIS standard that describes both a policy language and an access control decision request/response language (both written in XML). The policy language is used to describe general access control requirements, and has standard extension points for defining new functions, data types, combining logic, etc. The request/response language lets you form a query to ask whether or not a given action should be allowed, and interpret the result. The response always includes an answer about whether the request should be allowed using one of four values: Permit, Deny, Indeterminate (an error occurred or some required value was missing, so a decision cannot be made) or Not Applicable (the request can't be answered by this service). 
\par 
The typical setup is that anyone wants to take some action on a resource. That is making a request to whatever actually protects that resource (like a filesystem or a web server), which is called a Policy Enforcement Point (PEP). The PEP will form a request based on the requester's attributes, the resource in question, the action, and other information pertaining to the request. The PEP will then send this request to a Policy Decision Point (PDP), which will look at the request and some policy that applies to the request, and come up with an answer about whether access should be granted. That answer is returned to the PEP, which can then allow or deny access to the requester. Note that the PEP and PDP might both be contained within a single application, or might be distributed across several servers. In addition to providing request/response and policy languages, XACML also provides the other pieces of this relationship, namely finding a policy that applies to a given request and evaluating the request against that policy to come up with a yes or no answer. 

\subsubsection{Policy and Policyset}
\hspace{5mm}At the root of all XACML policies is a Policy or a PolicySet. A PolicySet is a container that can hold other Policies or PolicySets, as well as references to policies found in remote locations. A Policy represents a single access control policy, expressed through a set of Rules. Each XACML policy document contains exactly one Policy or PolicySet root XML tag. 
\par Because a Policy or PolicySet may contain multiple policies or Rules, each of which may evaluate to different access control decisions, XACML needs some way of reconciling the decisions each makes. This is done through a collection of Combining Algorithms. Each algorithm represents a different way of combining multiple descisions into a single descision. There are Policy Combining Algorithms (used by PolicySet) and Rule Combining Algorithms (used by Policy). An example of these is the Deny Overrides Algorithm, which says that no matter what, if any evaluation returns Deny, or no evaluation permits, then the final result is also Deny. These Combining Algorithms are used to build up increasingly complex policies, and while there are seven standard algorithms, you can build your own to suit your needs.

\subsubsection{Parameters and Notations of Rules}
\hspace{5mm} In the field of access control and authorization there are several closely related terms in common use. For purposes of precision and clarity, certain of these terms are not used in this specification.For instance, the term attribute is used in place of the terms: group and role.
In place of the terms: privilege, permission, authorization, entitlement and right, we use the term rule.The term object is also in common use, but we use the term resource in this specification.Requestors and initiators are covered by the term subject.

\subsubsection{Notation} 
\hspace{5mm}This specification contains schema conforming to W3C XML Schema and normative text to describe the syntax and semantics of XML-encoded policy statements.
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
"SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this specification are to be
interpreted as described in IETF RFC 2119.
\par The XACML policy syntax is defined in a schema associated with the following XML namespace:
\begin{center}
urn:oasis:names:tc:xacml:1.0:policy
\end{center} 
The XACML context syntax is defined in a schema associated with the following XML namespace:
\begin{center}
urn:oasis:names:tc:xacml:1.0:context
\end{center}
The XML Signature [DS] is imported into the XACML schema and is associated with the following XML namespace:


\subsubsection{Requirements}
\hspace{5mm}The basic requirements of a policy language for expressing information system security policy are:
\begin{itemize}
\item To provide a method for combining individual rules and policies into a single policy set that
applies to a particular decision request.
\item To provide a method for flexible definition of the procedure by which rules and policies are
combined.
\item To provide a method for dealingwith multiple subjects acting in different capacities.
\item To provide a method for basing an authorization decision on attributes of the subject and
resource.
\item To provide a method for dealing with multi-valued attributes.
\item To provide a method for basing an authorization decision on the contents of an information
resource.
\item To provide a set of logical and mathematical operators on attributes of the subject, resource
and environment.
\item To provide a method for handling a distributed set of policy components, while abstracting the
method for locating, retrieving and authenticating the policy components.
\item To provide a method for rapidly identifying the policy that applies to a given action, based upon
the values of attributes of the subjects, resource and action.
\item To provide an abstraction-layer that insulates the policy-writer from the details of the application
environment.
\item To provide a method for specifying a set of actions that must be performed in conjunction with
policy enforcement.
\end{itemize}

\subsubsection{Rule and Policy Combining}
\hspace{5mm}The complete policy applicable to a particular decision request may be composed of a number of individual rules or policies. For instance, in a personal privacy application, the owner of the
personal information may define certain aspects of disclosure policy, whereas the enterprise that is
the custodian of the information may define certain other aspects. In order to render an
authorization decision, it must be possible to combine the two separate policies to form the
single policy applicable to the request.
XACML defines three top-level policy elements: \textless Rule\textgreater  , \textless Policy\textgreater   and \textless
PolicySet\textgreater  . The \textless
Rule\textgreater   element contains a boolean expression that can be evaluated in isolation, but that is not intended to be accessed in isolation by a PDP. So, it is not intended to form the basis of an authorization decision by itself. It is intended to exist in isolation only within an XACML PAP, where it may form the basic unit of management, and be re-used in multiple policies.
The \textless Policy\textgreater   element contains a set of \textless Rule\textgreater   elements and a specified procedure for
combining the results of their evaluation. It is the basic unit of policy used by the PDP, and so it is
intended to form the basis of an authorization decision.
The \textless PolicySet\textgreater   element contains a set of \textless Policy\textgreater   or other \textless PolicySet\textgreater   elements and a
specified procedure for combining the results of their evaluation. It is the standard means for
combining separate policies into a single combined policy.

\subsubsection{Combining Algorithms}
\hspace{5mm}XACML defines a number of combining algorithms that can be identified by a
RuleCombiningAlgId or PolicyCombiningAlgId attribute of the \textless Policy\textgreater   or \textless PolicySet\textgreater  
elements, respectively. The rule-combining algorithm defines a procedure for arriving at an
authorization decision given the individual results of evaluation of a set of rules. Similarly, the
policy-combining algorithm defines a procedure for arriving at an authorization decision given
the individual results of evaluation of a set of policies. Standard combining algorithms are defined
for:
\begin{itemize}
\item Deny-overrides,
\item Permit-overrides,
\item First applicable and
\item Only-one-applicable.
\end{itemize}
In the first case, if a single \textless Rule\textgreater   or <Policy\textgreater   element is encountered that evaluates to "Deny",
then, regardless of the evaluation result of the other \textless Rule\textgreater   or \textless Policy\textgreater   elements in the
applicable policy, the combined result is "Deny". Likewise, in the second case, if a single "Permit"
result is encountered, then the combined result is "Permit". In the case of the “First-applicable” combining algorithm, the combined result is the same as the result of evaluating the first \textless Rule\textgreater  ,
\textless Policy\textgreater   or \textless PolicySet\textgreater   element in the list of rules whose target is applicable to the decision
request. The "Only-one-applicable" policy-combining algorithm only applies to policies. The
result of this combining algorithm ensures that one and only one policy or policy set is applicable
by virtue of their targets. If no policy or policy set applies, then the result is "NotApplicable", but if
more than one policy or policy set is applicable, then the result is "Indeterminate". When exactly
one policy or policy set is applicable, the result of the combining algorithm is the result of
evaluating the single applicable policy or policy set.

\subsection{XACML context in Policy}
\hspace{5mm}XACML is intended to be suitable for a variety of application environments. The core language is insulated from the application environment by the XACML context, as shown in Figure 3.2, in which
the scope of the XACML specification is indicated by the shaded area. The XACML context is
defined in XML schema, describing a canonical representation for the inputs and outputs of the
PDP. Attributes referenced by an instance of XACML policy may be in the form of XPath
expressions on the context, or attribute designators that identify the attribute by subject,
resource, action or environment and its identifier. Implementations must convert between the
attribute representations in the application environment (e.g., SAML, J2SE, CORBA, and so on)
and the attribute representations in the XACML context. How this is achieved is outside the
scope of the XACML specification. In some cases, such as SAML, this conversion may be accomplished in an automated way through the use of an XSLT transformation.
\begin{figure}[h!]
\begin{center}
\scalebox{0.50}{\includegraphics{xacml-policy.jpg}}
\end{center}
\caption {XACML Context}
\label{vmb2}
\vspace{0mm}
\end{figure}

\subsection{Policy Language Model}
\hspace{5mm}The policy language model is shown in Figure 3.3. The main components of the model are:
\begin{itemize}
\item Rule;
\item Policy; and
\item Policy set.
\end{itemize}

\subsubsection{Rule}
\hspace{5mm}A rule is the most elementary unit of policy. It may exist in isolation only within one of the major actors of the XACML domain. In order to exchange rules between major actors, they must be
encapsulated in a policy. A rule can be evaluated on the basis of its contents. The main
components of a rule are:
\begin{itemize}
\item a target;
\item an effect; and
\item a condition.
\end{itemize}
The \textbf{target} of the rule defines the set of:
\begin{itemize}
\item resources;
\item subjects; and
\item actions
\end{itemize}
to which the rule is intended to apply. The \textless Condition\textgreater   element may further refine the
applicability established by the target. If the rule is intended to apply to all entities of a particular
data-type, then an empty element named \textless AnySubject/\textgreater  , \textless AnyResource/\textgreater   or \textless AnyAction/\textgreater  
is used. An XACML PDP verifies that the subjects, resource and action identified in the request
context are all present in the target of the rules that it uses to evaluate the decision request.
Target definitions are discrete, in order that applicable rules may be efficiently identified by the
PDP.
The \textless Target\textgreater   element may be absent from a \textless Rule\textgreater  . In this case, the target of the \textless Rule\textgreater   is
the same as that of the parent \textless Policy\textgreater   element.
The \textbf{effect} of the rule indicates the rule-writer's intended consequence of a "True" evaluation for the rule. Two values are allowed: "Permit" and "Deny".\textbf{Condition} represents a boolean expression that refines the applicability of the rule beyond the predicates implied by its target. Therefore, it may be absent.

\subsubsection{Policy}
\hspace{5mm}From the policy model shown in figure 3.3 one can see that rules are not exchanged amongst system entities.
\begin{figure}[h!]
\begin{center}
\scalebox{0.60}{\includegraphics{policy-model.jpg}}
\end{center}
\caption {Policy Language Model}
\label{vmb2}
\vspace{0mm}
\end{figure}

Therefore, a PAP combines rules in a policy. A policy comprises four main components:
\begin{itemize}
\item a target;
\item a rule-combining algorithm-identifier;
\item a set of rules; and
\item obligations.
\end{itemize}
An XACML \textless PolicySet\textgreater  , \textless Policy\textgreater   or \textless Rule\textgreater   element contains a \textless Target\textgreater   element that
specifies the set of subjects, resources and actions to which it applies.
\par A system entity that calculates a \textless Target\textgreater   in this way is not defined by XACML, but there are two
logical methods that might be used. In one method, the \textless Target\textgreater   element of the outer
\textless PolicySet\textgreater   or \textless Policy\textgreater   (the "outer component") is calculated as the union of all the
\textless Target\textgreater   elements of the referenced \textless PolicySet\textgreater  , \textless Policy\textgreater   or \textless Rule\textgreater   elements (the "inner
components"). In another method, the \textless Target\textgreater   element of the outer component is calculated as
the intersection of all the \textless Target\textgreater   elements of the inner components. The results of evaluation in
each case will be very different: in the first case, the \textless Target\textgreater   element of the outer component
makes it applicable to any decision request that matches the \textless Target\textgreater   element of at least one
inner component; in the second case, the \textless Target\textgreater   element of the outer component makes it
applicable only to decision requests that match the \textless Target\textgreater   elements of every inner
component. Note that computing the intersection of a set of \textless Target\textgreater   elements is likely only
practical if the target data-model is relatively simple.
\par In cases where the \textless Target\textgreater   of a \textless Policy\textgreater   is declared by the policy writer, any component
\textless Rule\textgreater   elements in the \textless Policy\textgreater   that have the same \textless Target\textgreater   element as the \textless Policy\textgreater  
element may omit the \textless Target\textgreater   element. Such \textless Rule\textgreater   elements inherit the \textless Target\textgreater   of the
\textless Policy\textgreater   in which they are contained.














